
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>scheduler</title>
      <meta name="generator" content="MATLAB 7.8">
      <meta name="date" content="2009-04-23">
      <meta name="m-file" content="scheduler"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content"><pre class="codeinput"><span class="comment">% battery simulator</span>
<span class="keyword">function</span> scheduler
clear <span class="string">all</span>
close <span class="string">all</span>
<span class="comment">% figure out this battery's characteristics</span>
<span class="comment">% amphere-hour, trade-off btw recovery efficiency and discharge rate</span>
<span class="comment">% 60 seconds : 60 coulumbs then 1 hour : 3600 coulumbs</span>
<span class="comment">% 1 coulumb : 1 sec : 23A/m2</span>
<span class="comment">% SOC scale is the same as lifetime</span>
<span class="comment">% SOC = 1 - sum of coulombs discharged/nominal coulombs</span>
<span class="comment">% nominal coulombs = 7200 means it lasts 2 hours when 1 coulomb per sec</span>
<span class="comment">% So, e.g., 20 Amp for 100 secs and 0.1 for the rest, ave amp is then</span>
<span class="comment">% 20*100/7200 + 0.1*7100/7200 =0.0986 amp</span>
<span class="comment">% the lifetime is 7200/0.0986 = 73022 secs</span>

<span class="comment">% init: number of cells, nominal coulombs of each</span>
<span class="comment">% input: number of coulombs in each interval (ms)</span>
<span class="comment">% process: calculate SOC of each Note coulombs not change but voltage</span>
<span class="comment">% output: number of coulumbs discharged in each interval</span>

<span class="comment">% init: number of cells, nominal coulombs of each</span>
max_cap=3602.7; <span class="comment">%coulombs 3602.7</span>
max_volt=4.306267;
nomcells=4;
battery_pack=[];
battery_voltage=[];
k=0; <span class="comment">% # of active cells (selected) every cycle</span>
<span class="comment">%GH=[];GL=[];</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%offlin setup voltage and recovery functions</span>
<span class="comment">% discharge rate</span>
<span class="comment">%[1-8], [9-18], [19-23], [24-34], [35-64], [65-80], [81-90],[91-100]</span>
<span class="comment">%inx=[1, 9, 19, 24, 35, 65, 81, 91, 101];</span>
<span class="keyword">if</span> 0
inx=[1,24,65,101];
min_pw=[];
<span class="keyword">for</span> i=1:length(inx)-1
    pw=calcul_coeff_volt(inx(i),inx(i+1)-1); <span class="comment">%in minute</span>
    min_pw=[min_pw struct(<span class="string">'id'</span>,(inx(i+1)-1)/23,<span class="string">'pw'</span>,pw)];
    <span class="comment">%min_pw=[min_pw; [inx(i+1)-1 pw]];</span>
<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% recovery rate</span>
<span class="comment">% returns coeff of RT1;RT2;RT10 based on Coulomb</span>
coeff_re=calcul_coeff_re(1,100); <span class="comment">%[p1; p2; p10]</span>
<span class="comment">% find max recovery efficiency</span>
p=coeff_re(1,:);
dep=polyder(p);
ddep=polyder(dep);
x=[0:0.00002:4];
ind=find(polyval(dep,x)&lt;=0.000002 &amp; polyval(dep,x)&gt;=-0.000002);
maxreC=[];
<span class="keyword">for</span> l=1:length(ind)
    <span class="keyword">if</span> polyval(ddep,x(ind(l))) &lt; 0 &amp; x(ind(l)) &gt; 0.5
        maxreC=[maxreC x(ind(l))];
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%maxreC=[0.8261 2.0435];</span>
refC=Vref(<span class="string">'dat/dualfoil5C23.out'</span>);
[coeff]=calcul_coeff_volt_new(1,100,refC);

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%profiling load demand</span>
runtimeratio=1; <span class="comment">%0 to 1 (100% to 0%)</span>
interval=60;<span class="comment">%every x second(s)</span>
lower_demand=0.3*interval; <span class="comment">%C1 (= 23A/m2)</span>
upper_demand=4*interval;   <span class="comment">%C4</span>
max_demand=upper_demand;
load_delta=lower_demand;
max_runtime=floor((max_cap*runtimeratio)*60/interval); <span class="comment">%minute</span>
load_demand=[];
dis_type=<span class="string">'const1'</span>;

<span class="keyword">switch</span> dis_type
    <span class="keyword">case</span> <span class="string">'rand'</span>
        load_demand=loadfile(<span class="string">'dat/log/load_demand-rand0.txt'</span>,<span class="string">'%d '</span>, [1 Inf]);
        <span class="keyword">if</span> isempty(load_demand) | load_demand&lt;0
            load_demand=lower_demand;
            <span class="keyword">for</span> i=2:max_runtime
                derivative=load_demand(i-1)+round(load_delta*normrnd(0,0.5));
                <span class="keyword">if</span> derivative &gt; upper_demand
                    derivative=upper_demand;
                <span class="keyword">elseif</span> derivative &lt; lower_demand
                    derivative=lower_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">if</span> savefile(load_demand,<span class="string">'%d '</span>,<span class="string">'dat/log/load_demand.txt'</span>)&lt;0
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">case</span> <span class="string">'const1'</span>
        load_demand=loadfile(<span class="string">'dat/log/load_demand-const10.txt'</span>,<span class="string">'%d '</span>, [1 Inf]);
        <span class="keyword">if</span> isempty(load_demand) | load_demand&lt;0
            load_demand=lower_demand;
            upper_demand=maxreC(1)*23*(round(nomcells*0.5));
            <span class="keyword">for</span> i=2:round(max_runtime*0.025)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &gt; upper_demand
                    derivative=upper_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">for</span> i=round(max_runtime*0.025)+1:max_runtime
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &lt; lower_demand
                    derivative=lower_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">if</span> savefile(load_demand,<span class="string">'%d '</span>,<span class="string">'dat/log/load_demand.txt'</span>)&lt;0
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">case</span> <span class="string">'const2'</span>
        load_demand=loadfile(<span class="string">'dat/log/load_demand-const20.txt'</span>,<span class="string">'%d '</span>, [1 Inf]);
        <span class="keyword">if</span> isempty(load_demand) | load_demand&lt;0
            load_demand=lower_demand;
            upper_demand=maxreC(2)*23*(round(nomcells*0.5));
            <span class="keyword">for</span> i=2:round(max_runtime*0.05)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &gt; upper_demand
                    derivative=upper_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">for</span> i=round(max_runtime*0.05)+1:max_runtime
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &lt; lower_demand
                    derivative=lower_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">if</span> savefile(load_demand,<span class="string">'%d '</span>,<span class="string">'dat/log/load_demand.txt'</span>)&lt;0
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">case</span> <span class="string">'const3'</span>
        load_demand=loadfile(<span class="string">'dat/log/load_demand-const30.txt'</span>,<span class="string">'%d '</span>, [1 Inf]);
        <span class="keyword">if</span> isempty(load_demand) | load_demand&lt;0
            load_demand=lower_demand;
            upper_demand=maxreC(1)*23*(round(nomcells*0.5));
            <span class="keyword">for</span> i=2:round(max_runtime*0.025)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &gt; upper_demand
                    derivative=upper_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">for</span> i=round(max_runtime*0.025)+1:round(max_runtime*0.05)
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &lt; lower_demand
                    derivative=lower_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">for</span> i=round(max_runtime*0.05)+1:round(max_runtime*0.1)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &gt; upper_demand
                    derivative=upper_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">for</span> i=round(max_runtime*0.1)+1:max_runtime
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                <span class="keyword">if</span> derivative &lt; lower_demand
                    derivative=lower_demand;
                <span class="keyword">end</span>
                load_demand=[load_demand derivative];
            <span class="keyword">end</span>
            <span class="keyword">if</span> savefile(load_demand,<span class="string">'%d '</span>,<span class="string">'dat/log/load_demand.txt'</span>)&lt;0
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

<span class="keyword">end</span> <span class="comment">%switch</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Init parameter</span>
thres_g=upper_demand/max_cap * 4;<span class="comment">% 0.2:</span>
shutdown=thres_g*0.2;
<span class="comment">%pw=hashing(min_pw,upper_demand/interval);</span>
<span class="comment">%cutoff_voltage=polyval2(pw,upper_demand/interval,thres_g);%3.5; %voltage cutoff</span>
ind=find(refC.sX&lt;=0.005);
cutoff_voltage=polyval(refC.p,refC.tX(ind(1)));
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">% Setup Battery packs</span>
numofsch=4;
name=[<span class="string">'kRR'</span>;<span class="string">'1RR'</span>;<span class="string">'Seq'</span>;<span class="string">'nRR'</span>];
batpack(1:nomcells)=max_cap;
batpack(1:nomcells)=[max_cap max_cap max_cap  max_cap];<span class="comment">%max_cap*0.90];</span>
batvolt(1:nomcells)=max_volt;
batvolt(1:nomcells)=[max_volt max_volt max_volt  max_volt];<span class="comment">%max_volt*0.90];</span>
bat_pack=[];
init(1:nomcells)=0;
<span class="keyword">for</span> i=1:numofsch
    bat_pack=[bat_pack struct(<span class="string">'id'</span>,name(i,:),<span class="string">'bpack'</span>,batpack,<span class="keyword">...</span>
        <span class="string">'bvolt'</span>,batvolt,<span class="string">'RE'</span>,init,<span class="string">'ldisch'</span>,init,<span class="string">'GH'</span>,find(batpack&gt;thres_g*max_cap),<span class="keyword">...</span>
        <span class="string">'GL'</span>,find(batpack&lt;=thres_g*max_cap),<span class="string">'k'</span>,[],<span class="string">'thres_g'</span>,thres_g,<span class="string">'status'</span>,0,<span class="keyword">...</span>
        <span class="string">'soc_log'</span>,[],<span class="string">'volt_log'</span>,[],<span class="string">'ldiff_log'</span>,[],<span class="string">'vdiff_log'</span>,[],<span class="string">'load_log'</span>,[])];
<span class="keyword">end</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%log</span>
soc_log=[];
volt_log=[];
load_log=[];
ldiff_log=[];
vdiff_log=[];
otime_log(1:numofsch)=0;
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>

sch_policy=1; <span class="comment">%1: k-RR; 2:1-RR; 3:sequential; 4:parallel</span>
temp_pack=[];temp_volt=[];

listofsch=[1 2 3 4];
<span class="keyword">for</span> i=1:max_runtime <span class="comment">%second</span>
    <span class="comment">%avail_pack=battery_pack(GH);</span>
    <span class="comment">%avail_volt=battery_voltage(GH);</span>

    <span class="keyword">if</span> isempty(listofsch)
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
    <span class="comment">%log in each interval of 100ms</span>
    <span class="keyword">for</span> j=listofsch
        bat_pack(j).soc_log=[bat_pack(j).soc_log; bat_pack(j).bpack/max_cap];
        bat_pack(j).volt_log=[bat_pack(j).volt_log; bat_pack(j).bvolt];
    <span class="keyword">end</span>
    <span class="comment">%soc_log=[soc_log; battery_pack/max_cap];</span>
    <span class="comment">%volt_log=[volt_log; battery_voltage];</span>

    <span class="comment">%num_cells=length(avail_pack);</span>

    <span class="keyword">for</span> j=listofsch
        <span class="keyword">switch</span> j
            <span class="keyword">case</span> 1<span class="comment">%kRR</span>
                <span class="comment">% Recovery effect check</span>
                <span class="comment">% Increase volt if condition is met</span>
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                <span class="keyword">if</span> isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(bat_pack(j).bvolt(bat_pack(j).GL)&gt;cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    <span class="keyword">if</span> isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        <span class="keyword">continue</span>;
                    <span class="keyword">end</span>
                    bat_pack(j).status=1; <span class="comment">%capacity status: low</span>
                <span class="keyword">end</span>

                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);

                prior2load=bat_pack(j).bpack;
                num_cells=length(avail_pack);
                k=0;

                <span class="keyword">if</span> 0
                    k=ceil(num_cells * load_demand(i) / max_demand);
                <span class="keyword">else</span> <span class="comment">% adjust load_demand to fit max recovery</span>
                    <span class="comment">%vector of second order of derivative</span>
                    ok=round(load_demand(i)./(maxreC*23));
                    <span class="keyword">if</span> ok(1)&gt; num_cells
                        k=ok(1)-ok(2);
                    <span class="keyword">elseif</span> ok(1)&lt;1
                        k=1;
                    <span class="keyword">else</span>
                        k=ok(1);
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> k &gt; num_cells
                        k=num_cells
                    <span class="keyword">end</span>
                 <span class="keyword">end</span> <span class="comment">%if 0 or 1</span>

                <span class="keyword">if</span> bat_pack(j).status <span class="comment">%when soc is low then nRR</span>
                    k=num_cells;
                <span class="keyword">end</span>

                bat_pack(j).k=[bat_pack(j).k k];

                <span class="keyword">if</span> 1
                    sp=sorted_index(avail_pack);
                <span class="keyword">else</span> <span class="comment">%recovered cells first</span>
                    ldisch=find(bat_pack(j).ldisch(bat_pack(j).GH)==0); <span class="comment">%if ldisch==0 re</span>
                    sp=0;si=sorted_index(avail_pack);
                    <span class="keyword">if</span> ~isempty(ldisch)
                        sp=ldisch;
                        <span class="keyword">for</span> m=1:length(si)
                            <span class="keyword">if</span> isempty(find(si(m)==ldisch))
                                sp=[sp si(m)];
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">else</span>
                        sp=si;
                    <span class="keyword">end</span>
                <span class="keyword">end</span> <span class="comment">%if 0 or 1</span>

                <span class="comment">% distribute workloads</span>
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,<span class="keyword">...</span>
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff);
                indx=find(bat_pack(j).bvolt&lt;0);

                <span class="comment">% Recovery count</span>
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                <span class="comment">% update SoC and Voltage</span>
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                <span class="comment">%log</span>
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; <span class="keyword">...</span>
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                <span class="comment">%update GH</span>
                down=merge(find(avail_pack&lt;=bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&lt;=cutoff_voltage)); <span class="comment">%| or operation</span>
                <span class="keyword">if</span> ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&gt;cutoff_voltage)); <span class="comment">%&amp; and disjoint</span>
                    bat_pack(j).GH=bat_pack(j).GH(com);
                <span class="keyword">end</span>
                <span class="keyword">if</span> bat_pack(j).thres_g &lt; shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                <span class="keyword">end</span>;

            <span class="keyword">case</span> 2 <span class="comment">%rr</span>
                <span class="comment">% Recovery effect check</span>
                <span class="comment">% Increase volt if condition is met</span>
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                <span class="keyword">if</span> isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(bat_pack(j).bvolt(bat_pack(j).GL)&gt;cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    <span class="keyword">if</span> isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        <span class="keyword">continue</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                prior2load=bat_pack(j).bpack;
                k=1;
                bat_pack(j).k=[bat_pack(j).k k];
                sp=sorted_index(avail_pack);
                <span class="comment">% distribute workloads</span>
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,<span class="keyword">...</span>
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff);

                <span class="comment">% Recovery count</span>
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                <span class="comment">% update SoC and Voltage</span>
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                <span class="comment">%log</span>
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; <span class="keyword">...</span>
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                <span class="comment">%update GH</span>
                down=merge(find(avail_pack&lt;=bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&lt;=cutoff_voltage)); <span class="comment">%| op</span>
                <span class="keyword">if</span> ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&gt;cutoff_voltage)); <span class="comment">%&amp; and disjoint</span>
                    bat_pack(j).GH=bat_pack(j).GH(com);
                <span class="keyword">end</span>
                <span class="keyword">if</span> bat_pack(j).thres_g &lt; shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                <span class="keyword">end</span>;

            <span class="keyword">case</span> 3 <span class="comment">%sequentail</span>
                <span class="comment">% Recovery effect check</span>
                <span class="comment">% Increase volt if condition is met</span>
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                <span class="comment">%termination condition</span>
                <span class="comment">%At the low voltage level, volt is a determinator to move</span>
                <span class="comment">%We only move elements of high soc and volt into GH from GL</span>
                <span class="keyword">if</span> isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(bat_pack(j).bvolt(bat_pack(j).GL)&gt;cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    <span class="keyword">if</span> isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        <span class="keyword">continue</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                prior2load=bat_pack(j).bpack;
                k=1;
                bat_pack(j).k=[bat_pack(j).k k];
                sp=1;
                <span class="comment">% distribute workloads</span>
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,<span class="keyword">...</span>
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff);
                <span class="comment">% Recovery count</span>
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                <span class="comment">% update SoC and Voltage</span>
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                <span class="comment">%log</span>
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; <span class="keyword">...</span>
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                <span class="comment">%update GH</span>
                down=merge(find(avail_pack&lt;=bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&lt;=cutoff_voltage)); <span class="comment">%| op</span>
                <span class="keyword">if</span> ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&gt;cutoff_voltage)); <span class="comment">%&amp; and disjoint</span>
                    bat_pack(j).GH=bat_pack(j).GH(com);
                <span class="keyword">end</span>
                <span class="keyword">if</span> bat_pack(j).thres_g &lt; shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                <span class="keyword">end</span>;

            <span class="keyword">case</span> 4 <span class="comment">%parallel</span>
                <span class="comment">% Recovery effect check</span>
                <span class="comment">% Increase volt if condition is met</span>
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                <span class="keyword">if</span> isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(bat_pack(j).bvolt(bat_pack(j).GL)&gt;cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    <span class="keyword">if</span> isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        <span class="keyword">continue</span>;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                prior2load=bat_pack(j).bpack;
                k=length(avail_pack);
                bat_pack(j).k=[bat_pack(j).k k];
                sp=sorted_index(avail_pack);
                <span class="comment">% distribute workloads</span>
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,<span class="keyword">...</span>
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff);
                <span class="comment">% Recovery count</span>
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                <span class="comment">% update SoC and Voltage</span>
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                <span class="comment">%log</span>
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; <span class="keyword">...</span>
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                <span class="comment">%update GH</span>
                down=merge(find(avail_pack&lt;=bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&lt;=cutoff_voltage)); <span class="comment">%| op</span>
                <span class="keyword">if</span> ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack&gt;bat_pack(j).thres_g*max_cap),<span class="keyword">...</span>
                    find(avail_volt&gt;cutoff_voltage)); <span class="comment">%&amp; and disjoint</span>
                    bat_pack(j).GH=bat_pack(j).GH(com);
                <span class="keyword">end</span>
                <span class="keyword">if</span> bat_pack(j).thres_g &lt; shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                <span class="keyword">end</span>;

        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">%for</span>

figure
<span class="keyword">for</span> j=1:numofsch
    subplot(2,2,j);plot(bat_pack(j).soc_log,<span class="string">':'</span>,<span class="string">'MarkerSize'</span>,10,<span class="string">'LineWidth'</span>,2); title(name(j,:));
    xlabel(<span class="string">'time step'</span>,<span class="string">'FontSize'</span>,12); ylabel(<span class="string">'SoC level'</span>,<span class="string">'FontSize'</span>,12);
<span class="keyword">end</span>

figure
<span class="keyword">for</span> j=1:numofsch
    subplot(2,2,j);plot(bat_pack(j).volt_log,<span class="string">'-'</span>,<span class="string">'MarkerSize'</span>,10,<span class="string">'LineWidth'</span>,2); title(name(j,:));
    xlabel(<span class="string">'time step'</span>,<span class="string">'FontSize'</span>,12); ylabel(<span class="string">'Voltage'</span>,<span class="string">'FontSize'</span>,12);
<span class="keyword">end</span>

figure
<span class="keyword">for</span> j=1:numofsch
<span class="comment">%for k=1:nomcells</span>
subplot(2,2,j);plot(bat_pack(j).ldiff_log,<span class="string">'x'</span>,<span class="string">'MarkerSize'</span>,4,<span class="string">'LineWidth'</span>,1);title(name(j,:));
<span class="comment">%end</span>
<span class="keyword">end</span>
<span class="comment">%xlabel('time step','FontSize',12); ylabel('Coulomb discharged','FontSize',12);</span>

figure <span class="comment">%ldiff.fig</span>
<span class="comment">%for j=1:numofsch</span>
ln=length(bat_pack(1).load_log);
<span class="comment">%subplot(2,2,j);plot([1:ln],load_demand(1:ln),'-',[1:ln],bat_pack(j).load_log,'--','MarkerSize',10,'LineWidth',2);</span>
plot([1:ln],load_demand(1:ln),<span class="string">'-'</span>,[1:length(bat_pack(1).load_log)],bat_pack(1).load_log,<span class="string">'-o'</span>,<span class="keyword">...</span>
    [1:length(bat_pack(2).load_log)],bat_pack(2).load_log,<span class="string">'-+'</span>,<span class="keyword">...</span>
    [1:length(bat_pack(3).load_log)],bat_pack(3).load_log,<span class="string">'-d'</span>,<span class="keyword">...</span>
    [1:length(bat_pack(4).load_log)],bat_pack(4).load_log,<span class="string">'-x'</span>,<span class="string">'MarkerSize'</span>,4,<span class="string">'LineWidth'</span>,1);
<span class="comment">%title(name(j,:));</span>
legend(<span class="string">'Load demand'</span>,<span class="string">'kRR'</span>,<span class="string">'1RR'</span>,<span class="string">'1+1RR'</span>,<span class="string">'nRR'</span>);
xlabel(<span class="string">'time step (n\times \Delta t)'</span>,<span class="string">'FontSize'</span>,12);ylabel(<span class="string">'Load (Coulombs)'</span>,<span class="string">'FontSize'</span>,12);
<span class="comment">%end</span>

figure <span class="comment">%vdiff.fig</span>
<span class="comment">%for j=1:numofsch</span>
<span class="comment">%subplot(2,2,j);plot(bat_pack(j).vdiff_log,'-','MarkerSize',10,'LineWidth',2); title(name(j,:));</span>
plot([1:numel(bat_pack(1).vdiff_log)],bat_pack(1).vdiff_log,<span class="string">'-o'</span>,<span class="keyword">...</span>
    [1:numel(bat_pack(2).vdiff_log)],bat_pack(2).vdiff_log,<span class="string">'-+'</span>,<span class="keyword">...</span>
    [1:numel(bat_pack(3).vdiff_log)],bat_pack(3).vdiff_log,<span class="string">'-d'</span>,<span class="keyword">...</span>
    [1:numel(bat_pack(4).vdiff_log)],bat_pack(4).vdiff_log,<span class="string">'-x'</span>,<span class="string">'MarkerSize'</span>,4,<span class="string">'LineWidth'</span>,1);
legend(<span class="string">'kRR'</span>,<span class="string">'1RR'</span>,<span class="string">'1+1RR'</span>,<span class="string">'nRR'</span>);
xlabel(<span class="string">'time step'</span>,<span class="string">'FontSize'</span>,12);ylabel(<span class="string">'Difference in Voltage ((V_{max}-V_{min})/V_{max} \times 100 %)'</span>,<span class="string">'FontSize'</span>,12);
<span class="comment">%vdiff_log;</span>
<span class="comment">%end</span>

figure
out=[];
<span class="keyword">for</span> j=1:numofsch
    out=[out; (max_cap-bat_pack(j).bpack)/max_cap/nomcells];
<span class="keyword">end</span>
bar(out, <span class="string">'stack'</span>);ylabel(<span class="string">'Battery Untilization'</span>,<span class="string">'FontSize'</span>,12);xlabel(<span class="string">'Scheduling mechanisms'</span>,<span class="string">'FontSize'</span>,12);

deg=[];
<span class="comment">%ind=find(otime_log==min(otime_log));</span>
<span class="keyword">for</span> k=1:numel(otime_log)
    <span class="keyword">for</span> j=1:numel(otime_log)
        deg(k,j)=otime_log(k)/otime_log(j);
    <span class="keyword">end</span>
<span class="keyword">end</span>
figure <span class="comment">%opcomp.fig</span>
bar(deg);ylabel(<span class="string">'Operation-time gain'</span>,<span class="string">'FontSize'</span>,12);xlabel(<span class="string">'Scheduling mechanisms'</span>,<span class="string">'FontSize'</span>,12);
legend(<span class="string">'Comparison with kRR'</span>,<span class="string">'comparison with 1RR'</span>,<span class="string">'comparison with 1+1RR'</span>,<span class="string">'comparison with nRR'</span>);
</pre><pre class="codeoutput">Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
Warning: Polynomial is badly conditioned. Add points with distinct X
         values, reduce the degree of the polynomial, or try centering
         and scaling as described in HELP POLYFIT. 
</pre><img vspace="5" hspace="5" src="scheduler_01.png" alt=""> <img vspace="5" hspace="5" src="scheduler_02.png" alt=""> <img vspace="5" hspace="5" src="scheduler_03.png" alt=""> <img vspace="5" hspace="5" src="scheduler_04.png" alt=""> <img vspace="5" hspace="5" src="scheduler_05.png" alt=""> <img vspace="5" hspace="5" src="scheduler_06.png" alt=""> <img vspace="5" hspace="5" src="scheduler_07.png" alt=""> <p class="footer"><br>
            Published with MATLAB&reg; 7.8<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
% battery simulator
function scheduler
clear all
close all
% figure out this battery's characteristics
% amphere-hour, trade-off btw recovery efficiency and discharge rate
% 60 seconds : 60 coulumbs then 1 hour : 3600 coulumbs
% 1 coulumb : 1 sec : 23A/m2
% SOC scale is the same as lifetime
% SOC = 1 - sum of coulombs discharged/nominal coulombs
% nominal coulombs = 7200 means it lasts 2 hours when 1 coulomb per sec
% So, e.g., 20 Amp for 100 secs and 0.1 for the rest, ave amp is then
% 20*100/7200 + 0.1*7100/7200 =0.0986 amp
% the lifetime is 7200/0.0986 = 73022 secs

% init: number of cells, nominal coulombs of each
% input: number of coulombs in each interval (ms)
% process: calculate SOC of each Note coulombs not change but voltage
% output: number of coulumbs discharged in each interval

% init: number of cells, nominal coulombs of each
max_cap=3602.7; %coulombs 3602.7
max_volt=4.306267;
nomcells=4;
battery_pack=[];
battery_voltage=[];
k=0; % # of active cells (selected) every cycle
%GH=[];GL=[];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%offlin setup voltage and recovery functions
% discharge rate
%[1-8], [9-18], [19-23], [24-34], [35-64], [65-80], [81-90],[91-100]
%inx=[1, 9, 19, 24, 35, 65, 81, 91, 101];
if 0
inx=[1,24,65,101];
min_pw=[];
for i=1:length(inx)-1
    pw=calcul_coeff_volt(inx(i),inx(i+1)-1); %in minute
    min_pw=[min_pw struct('id',(inx(i+1)-1)/23,'pw',pw)];
    %min_pw=[min_pw; [inx(i+1)-1 pw]];
end;
end;

% recovery rate
% returns coeff of RT1;RT2;RT10 based on Coulomb
coeff_re=calcul_coeff_re(1,100); %[p1; p2; p10]
% find max recovery efficiency
p=coeff_re(1,:);
dep=polyder(p);
ddep=polyder(dep);
x=[0:0.00002:4];
ind=find(polyval(dep,x)<=0.000002 & polyval(dep,x)>=-0.000002);
maxreC=[];
for l=1:length(ind)
    if polyval(ddep,x(ind(l))) < 0 & x(ind(l)) > 0.5
        maxreC=[maxreC x(ind(l))];
    end
end
%maxreC=[0.8261 2.0435];
refC=Vref('dat/dualfoil5C23.out');
[coeff]=calcul_coeff_volt_new(1,100,refC);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%profiling load demand
runtimeratio=1; %0 to 1 (100% to 0%)
interval=60;%every x second(s)
lower_demand=0.3*interval; %C1 (= 23A/m2)
upper_demand=4*interval;   %C4
max_demand=upper_demand;
load_delta=lower_demand;
max_runtime=floor((max_cap*runtimeratio)*60/interval); %minute
load_demand=[];
dis_type='const1';

switch dis_type
    case 'rand'
        load_demand=loadfile('dat/log/load_demand-rand0.txt','%d ', [1 Inf]);
        if isempty(load_demand) | load_demand<0
            load_demand=lower_demand;
            for i=2:max_runtime
                derivative=load_demand(i-1)+round(load_delta*normrnd(0,0.5));
                if derivative > upper_demand
                    derivative=upper_demand;
                elseif derivative < lower_demand
                    derivative=lower_demand;
                end
                load_demand=[load_demand derivative];
            end
            if savefile(load_demand,'%d ','dat/log/load_demand.txt')<0
                return;
            end
        end
    case 'const1'
        load_demand=loadfile('dat/log/load_demand-const10.txt','%d ', [1 Inf]);
        if isempty(load_demand) | load_demand<0
            load_demand=lower_demand;
            upper_demand=maxreC(1)*23*(round(nomcells*0.5));
            for i=2:round(max_runtime*0.025)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                if derivative > upper_demand
                    derivative=upper_demand;
                end
                load_demand=[load_demand derivative];
            end
            for i=round(max_runtime*0.025)+1:max_runtime
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                if derivative < lower_demand
                    derivative=lower_demand;
                end
                load_demand=[load_demand derivative];
            end
            if savefile(load_demand,'%d ','dat/log/load_demand.txt')<0
                return;
            end
        end
    case 'const2'
        load_demand=loadfile('dat/log/load_demand-const20.txt','%d ', [1 Inf]);
        if isempty(load_demand) | load_demand<0
            load_demand=lower_demand;
            upper_demand=maxreC(2)*23*(round(nomcells*0.5));
            for i=2:round(max_runtime*0.05)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                if derivative > upper_demand
                    derivative=upper_demand;
                end
                load_demand=[load_demand derivative];
            end
            for i=round(max_runtime*0.05)+1:max_runtime
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                if derivative < lower_demand
                    derivative=lower_demand;
                end
                load_demand=[load_demand derivative];
            end
            if savefile(load_demand,'%d ','dat/log/load_demand.txt')<0
                return;
            end
        end
    case 'const3'
        load_demand=loadfile('dat/log/load_demand-const30.txt','%d ', [1 Inf]);
        if isempty(load_demand) | load_demand<0
            load_demand=lower_demand;
            upper_demand=maxreC(1)*23*(round(nomcells*0.5));
            for i=2:round(max_runtime*0.025)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                if derivative > upper_demand
                    derivative=upper_demand;
                end
                load_demand=[load_demand derivative];
            end
            for i=round(max_runtime*0.025)+1:round(max_runtime*0.05)
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                if derivative < lower_demand
                    derivative=lower_demand;
                end
                load_demand=[load_demand derivative];
            end
            for i=round(max_runtime*0.05)+1:round(max_runtime*0.1)
                derivative=load_demand(i-1)+round(0.05*load_delta*rand);
                if derivative > upper_demand
                    derivative=upper_demand;
                end
                load_demand=[load_demand derivative];
            end
            for i=round(max_runtime*0.1)+1:max_runtime
                derivative=load_demand(i-1)-round(0.05*load_delta*rand);
                if derivative < lower_demand
                    derivative=lower_demand;
                end
                load_demand=[load_demand derivative];
            end
            if savefile(load_demand,'%d ','dat/log/load_demand.txt')<0
                return;
            end
        end

end %switch        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Init parameter
thres_g=upper_demand/max_cap * 4;% 0.2: 
shutdown=thres_g*0.2;
%pw=hashing(min_pw,upper_demand/interval);
%cutoff_voltage=polyval2(pw,upper_demand/interval,thres_g);%3.5; %voltage cutoff
ind=find(refC.sX<=0.005);
cutoff_voltage=polyval(refC.p,refC.tX(ind(1)));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Setup Battery packs
numofsch=4;
name=['kRR';'1RR';'Seq';'nRR'];
batpack(1:nomcells)=max_cap;
batpack(1:nomcells)=[max_cap max_cap max_cap  max_cap];%max_cap*0.90];
batvolt(1:nomcells)=max_volt;
batvolt(1:nomcells)=[max_volt max_volt max_volt  max_volt];%max_volt*0.90];
bat_pack=[];
init(1:nomcells)=0;
for i=1:numofsch
    bat_pack=[bat_pack struct('id',name(i,:),'bpack',batpack,...
        'bvolt',batvolt,'RE',init,'ldisch',init,'GH',find(batpack>thres_g*max_cap),...
        'GL',find(batpack<=thres_g*max_cap),'k',[],'thres_g',thres_g,'status',0,...
        'soc_log',[],'volt_log',[],'ldiff_log',[],'vdiff_log',[],'load_log',[])];
end
%%%%%%%%%%%%%%%%%%%%%%%%%
%log
soc_log=[];
volt_log=[];
load_log=[];
ldiff_log=[];
vdiff_log=[];
otime_log(1:numofsch)=0;
%%%%%%%%%%%%%%%%%%%%%%%%%

sch_policy=1; %1: k-RR; 2:1-RR; 3:sequential; 4:parallel
temp_pack=[];temp_volt=[];

listofsch=[1 2 3 4];
for i=1:max_runtime %second
    %avail_pack=battery_pack(GH);
    %avail_volt=battery_voltage(GH);

    if isempty(listofsch)
        break;
    end
    %log in each interval of 100ms
    for j=listofsch
        bat_pack(j).soc_log=[bat_pack(j).soc_log; bat_pack(j).bpack/max_cap];
        bat_pack(j).volt_log=[bat_pack(j).volt_log; bat_pack(j).bvolt];
    end    
    %soc_log=[soc_log; battery_pack/max_cap];
    %volt_log=[volt_log; battery_voltage];
    
    %num_cells=length(avail_pack);
    
    for j=listofsch
        switch j
            case 1%kRR
                % Recovery effect check
                % Increase volt if condition is met
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                if isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)>bat_pack(j).thres_g*max_cap),...
                    find(bat_pack(j).bvolt(bat_pack(j).GL)>cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    if isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        continue;
                    end
                    bat_pack(j).status=1; %capacity status: low
                end

                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                
                prior2load=bat_pack(j).bpack;
                num_cells=length(avail_pack);
                k=0;
                              
                if 0
                    k=ceil(num_cells * load_demand(i) / max_demand);
                else % adjust load_demand to fit max recovery
                    %vector of second order of derivative
                    ok=round(load_demand(i)./(maxreC*23));
                    if ok(1)> num_cells
                        k=ok(1)-ok(2); 
                    elseif ok(1)<1
                        k=1;
                    else
                        k=ok(1);
                    end
                    if k > num_cells
                        k=num_cells
                    end
                 end %if 0 or 1
                
                if bat_pack(j).status %when soc is low then nRR
                    k=num_cells;
                end
                
                bat_pack(j).k=[bat_pack(j).k k];
                
                if 1
                    sp=sorted_index(avail_pack);
                else %recovered cells first
                    ldisch=find(bat_pack(j).ldisch(bat_pack(j).GH)==0); %if ldisch==0 re
                    sp=0;si=sorted_index(avail_pack);
                    if ~isempty(ldisch)
                        sp=ldisch;
                        for m=1:length(si)
                            if isempty(find(si(m)==ldisch))
                                sp=[sp si(m)];
                            end
                        end
                    else
                        sp=si;
                    end
                end %if 0 or 1
                
                % distribute workloads
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,...
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff); 
                indx=find(bat_pack(j).bvolt<0);
                
                % Recovery count
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);
                    
                % update SoC and Voltage               
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                %log
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; ...
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];
                
                %update GH
                down=merge(find(avail_pack<=bat_pack(j).thres_g*max_cap),...
                    find(avail_volt<=cutoff_voltage)); %| or operation
                if ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack>bat_pack(j).thres_g*max_cap),...
                    find(avail_volt>cutoff_voltage)); %& and disjoint
                    bat_pack(j).GH=bat_pack(j).GH(com);
                end
                if bat_pack(j).thres_g < shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                end;

            case 2 %rr
                % Recovery effect check
                % Increase volt if condition is met
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                if isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)>bat_pack(j).thres_g*max_cap),...
                    find(bat_pack(j).bvolt(bat_pack(j).GL)>cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    if isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        continue;
                    end
                end
                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                prior2load=bat_pack(j).bpack;
                k=1;
                bat_pack(j).k=[bat_pack(j).k k];
                sp=sorted_index(avail_pack);
                % distribute workloads
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,...
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff); 

                % Recovery count
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                % update SoC and Voltage
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                %log
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; ...
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                %update GH
                down=merge(find(avail_pack<=bat_pack(j).thres_g*max_cap),...
                    find(avail_volt<=cutoff_voltage)); %| op
                if ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack>bat_pack(j).thres_g*max_cap),...
                    find(avail_volt>cutoff_voltage)); %& and disjoint
                    bat_pack(j).GH=bat_pack(j).GH(com);
                end
                if bat_pack(j).thres_g < shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                end;
                
            case 3 %sequentail
                % Recovery effect check
                % Increase volt if condition is met
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                %termination condition
                %At the low voltage level, volt is a determinator to move
                %We only move elements of high soc and volt into GH from GL
                if isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)>bat_pack(j).thres_g*max_cap),...
                    find(bat_pack(j).bvolt(bat_pack(j).GL)>cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    if isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        continue;
                    end
                end
                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                prior2load=bat_pack(j).bpack;
                k=1;
                bat_pack(j).k=[bat_pack(j).k k];
                sp=1;
                % distribute workloads
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,...
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff); 
                % Recovery count
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                % update SoC and Voltage
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                %log
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; ...
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                %update GH
                down=merge(find(avail_pack<=bat_pack(j).thres_g*max_cap),...
                    find(avail_volt<=cutoff_voltage)); %| op
                if ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack>bat_pack(j).thres_g*max_cap),...
                    find(avail_volt>cutoff_voltage)); %& and disjoint
                    bat_pack(j).GH=bat_pack(j).GH(com);
                end
                if bat_pack(j).thres_g < shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                end;

            case 4 %parallel
                % Recovery effect check
                % Increase volt if condition is met
                [bat_pack(j).bvolt bat_pack(j).ldisch]=re_effect_check(bat_pack(j),coeff_re);
                if isempty(bat_pack(j).GH)
                    bat_pack(j).thres_g=bat_pack(j).thres_g/2;
                    [com dis]=leastcom(find(bat_pack(j).bpack(bat_pack(j).GL)>bat_pack(j).thres_g*max_cap),...
                    find(bat_pack(j).bvolt(bat_pack(j).GL)>cutoff_voltage));
                    bat_pack(j).GH=bat_pack(j).GL(com);
                    bat_pack(j).GL=bat_pack(j).GL(dis);
                    if isempty(bat_pack(j).GH)
                        listofsch=listofsch(find(listofsch ~= j));
                        otime_log(j)=i;
                        continue;
                    end
                end
                avail_pack=bat_pack(j).bpack(bat_pack(j).GH);
                avail_volt=bat_pack(j).bvolt(bat_pack(j).GH);
                prior2load=bat_pack(j).bpack;
                k=length(avail_pack);
                bat_pack(j).k=[bat_pack(j).k k];
                sp=sorted_index(avail_pack);
                % distribute workloads
                [avail_pack, avail_volt]=dischargingKcells(avail_pack,...
                avail_volt,load_demand(i),max_cap,interval,sp,k,refC,coeff); 
                % Recovery count
                [bat_pack(j).RE, bat_pack(j).ldisch]=recovery_count(bat_pack(j), avail_pack, interval);

                % update SoC and Voltage
                bat_pack(j).bpack(bat_pack(j).GH)=avail_pack;
                bat_pack(j).bvolt(bat_pack(j).GH)=avail_volt;
                %log
                bat_pack(j).ldiff_log=[bat_pack(j).ldiff_log; prior2load-bat_pack(j).bpack];
                bat_pack(j).vdiff_log=[bat_pack(j).vdiff_log; ...
                    (max(avail_volt)-min(avail_volt))/max(avail_volt)*100];
                bat_pack(j).load_log=[bat_pack(j).load_log; load_demand(i)/k];

                %update GH
                down=merge(find(avail_pack<=bat_pack(j).thres_g*max_cap),...
                    find(avail_volt<=cutoff_voltage)); %| op
                if ~isempty(down)
                    bat_pack(j).GL=[bat_pack(j).GL bat_pack(j).GH(down)];
                    [com, dis]=leastcom(find(avail_pack>bat_pack(j).thres_g*max_cap),...
                    find(avail_volt>cutoff_voltage)); %& and disjoint
                    bat_pack(j).GH=bat_pack(j).GH(com);
                end
                if bat_pack(j).thres_g < shutdown
                    listofsch=listofsch(find(listofsch ~= j));
                    otime_log(j)=i;
                end;

        end
    end
end %for

figure
for j=1:numofsch
    subplot(2,2,j);plot(bat_pack(j).soc_log,':','MarkerSize',10,'LineWidth',2); title(name(j,:));
    xlabel('time step','FontSize',12); ylabel('SoC level','FontSize',12);
end

figure
for j=1:numofsch
    subplot(2,2,j);plot(bat_pack(j).volt_log,'-','MarkerSize',10,'LineWidth',2); title(name(j,:));
    xlabel('time step','FontSize',12); ylabel('Voltage','FontSize',12);
end

figure
for j=1:numofsch
%for k=1:nomcells
subplot(2,2,j);plot(bat_pack(j).ldiff_log,'x','MarkerSize',4,'LineWidth',1);title(name(j,:));
%end
end
%xlabel('time step','FontSize',12); ylabel('Coulomb discharged','FontSize',12);

figure %ldiff.fig
%for j=1:numofsch
ln=length(bat_pack(1).load_log);
%subplot(2,2,j);plot([1:ln],load_demand(1:ln),'-',[1:ln],bat_pack(j).load_log,'REPLACE_WITH_DASH_DASH','MarkerSize',10,'LineWidth',2); 
plot([1:ln],load_demand(1:ln),'-',[1:length(bat_pack(1).load_log)],bat_pack(1).load_log,'-o',...
    [1:length(bat_pack(2).load_log)],bat_pack(2).load_log,'-+',...
    [1:length(bat_pack(3).load_log)],bat_pack(3).load_log,'-d',...
    [1:length(bat_pack(4).load_log)],bat_pack(4).load_log,'-x','MarkerSize',4,'LineWidth',1); 
%title(name(j,:));
legend('Load demand','kRR','1RR','1+1RR','nRR');
xlabel('time step (n\times \Delta t)','FontSize',12);ylabel('Load (Coulombs)','FontSize',12);
%end

figure %vdiff.fig
%for j=1:numofsch
%subplot(2,2,j);plot(bat_pack(j).vdiff_log,'-','MarkerSize',10,'LineWidth',2); title(name(j,:));
plot([1:numel(bat_pack(1).vdiff_log)],bat_pack(1).vdiff_log,'-o',...
    [1:numel(bat_pack(2).vdiff_log)],bat_pack(2).vdiff_log,'-+',...
    [1:numel(bat_pack(3).vdiff_log)],bat_pack(3).vdiff_log,'-d',...
    [1:numel(bat_pack(4).vdiff_log)],bat_pack(4).vdiff_log,'-x','MarkerSize',4,'LineWidth',1);
legend('kRR','1RR','1+1RR','nRR');
xlabel('time step','FontSize',12);ylabel('Difference in Voltage ((V_{max}-V_{min})/V_{max} \times 100 %)','FontSize',12);
%vdiff_log;
%end

figure
out=[];
for j=1:numofsch
    out=[out; (max_cap-bat_pack(j).bpack)/max_cap/nomcells];
end
bar(out, 'stack');ylabel('Battery Untilization','FontSize',12);xlabel('Scheduling mechanisms','FontSize',12);

deg=[];
%ind=find(otime_log==min(otime_log));
for k=1:numel(otime_log)
    for j=1:numel(otime_log)
        deg(k,j)=otime_log(k)/otime_log(j);
    end
end
figure %opcomp.fig
bar(deg);ylabel('Operation-time gain','FontSize',12);xlabel('Scheduling mechanisms','FontSize',12);
legend('Comparison with kRR','comparison with 1RR','comparison with 1+1RR','comparison with nRR');
##### SOURCE END #####
-->
   </body>
</html>